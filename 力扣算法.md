# 力扣算法

## 动态规划

1.给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

```java
对于任意整数 x，令 x=x & (x−1)，该运算将 x 的二进制表示的最后一个 1 变成 0。因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」
```

```java
y<x,y=max(2的整数次幂),z=x-y,bits[x]=bits[z]+1
```

```java
class Solution {
    public int[] countBits(int n) {
        int[] bits = new int[n + 1];
        int highBit = 0;
        for (int i = 1; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                highBit = i;
            }
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
}
动态规划不一定是找相邻两个数之间的关系，也可能是找相差特定数的关系
```

2.给定一个32位整数 `num`，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。

```java
current[i] 表示包含第i位的从num二进制低位至第i位连续1的最长长度
reverse[i] 表示包含第i位的从低位到第i位最多翻转1个0->1 的连续1的最长长度

用num[i]表示整数num第i位的值

当num[i]=1时，current[i] = current[i-1]+1,因为current[i-1]一定包含i-1位，也就是和第i位连续，所以前i-1的最大长度连上第i位的长度就等于current[i],同理reverse[i] = reverse[i-1]+1;
num[i]=0时，连续中断，current[i]=0,而reverse[i]允许翻转1次，但是reverse[i]又必须包含第i位，也就是说只能翻转第i位，所以前面不能出现翻转，必须全是1，这个长度恰好就是current[i-1]，所以reverse[i] = current[i-1]+1
遍历num所有位数，也就是32位后，reverse数组中的最大值就是答案。

状态方程：
current[i] = num[i]==1?current[i-1]+1:0
reverse[i] = num[i]==1?reverse[i-1]+1:current[i-1]+1

观察状态方程，我们发现current和reverse第i位只和第i-1位有关，所以可以把动态数组优化成两个变量current和reverse，同时更新最大值max并作为结果返回。
```



```java
class Solution {
    public int reverseBits(int num) {
        int max=0;
        int reverse=0;
        int current=0;
        for(int i=0;i<32;i++){
            if((num&1)==1){
                current++;
                reverse++;
            }
            else{
                reverse=current+1;
                current=0;
            }
            if(reverse>max) max=reverse;
            num>>=1;
        }
        return max;
    }
}
这道题有两个状态变量，之前见的都是一个状态变量
```

3.小扣打算给自己的 **VS code** 安装使用插件，初始状态下带宽每分钟可以完成 `1` 个插件的下载。假定每分钟选择以下两种策略之一:

- 使用当前带宽下载插件
- 将带宽加倍（下载插件数量随之加倍）

请返回小扣完成下载 `n` 个插件最少需要多少分钟。

注意：实际的下载的插件数量可以超过 `n` 个

```java
这种不是数组的动态规划题，之前有道题是考虑n和n-1的最优解的关系（只不过这两道题相似的点都是通过顺序枚举1，2，3，4发现了规律，只不过之前那道题是n和n-1有规律），但是这道题不是，这道题是通过顺序枚举1，2，3，4，5，6，7，8，9的最少分钟数，发现规律，发现虽然得到最小分钟数有许多策略，但是他们都和前面几分钟增加带宽，最后一分钟下载得到的最小分钟数相同
```

```ja
class Solution {
    public int leastMinutes(int n) {
        //3 3 0 0 4
        //5 0 0 0 8 =4  0 0 4 4=4
        //6 4 0 0 0 8
        //7 4 0 0 0 8
        //8 4 0 0 0 8
        //9 5 0 0 0 0 16
        //18 0 0 0 0 16 16
        // int k=1;
        // for(int i=1;i<=n;i++){
        //     if(i>Math.pow(2,k-1)){    //迭代找到小于n的最大2^x
        //         k+=1;
        //     }
        // }
        // return k;
        int k=0;
        int temp=n;
        while(n!=0){
            n=n>>1;       //通过位运算找，最多32次
            k++;
        }
        return Math.pow(2,k-1)>=temp?k:k+1;
    }
}
```

4.某公司每日销售额记于整数数组 `sales`，请返回所有 **连续** 一或多天销售额总和的最大值。要求实现时间复杂度为 `O(n)` 的算法。

```java
用 f(i) 代表以第 i 个数结尾的「连续天数的最高销售额」。这句话很关键，直接就把问题拆分成一个个小问题

只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i) 呢？我们可以考虑 sales[i] 单独成为一段还是加入 f(i−1) 对应的那一段，这取决于 sales[i] 和 f(i−1)+sales[i] 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：f(i)=max{f(i−1)+sales[i],sales[i]}

```

5.一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

```java
定义 dp[i][0] 表示考虑前 i 个预约，第 i 个预约不接的最长预约时间，dp[i][1] 表示考虑前 i 个预约，第 i 个预约接的最长预约时间。
dp[i][0]=max(dp[i−1][0],dp[i−1][1])
    
dp[i][1]=dp[i−1][0]+nums[i]
    
最后答案即为 max(dp[n][0],dp[n][1]) ，其中 n 表示预约的个数。

上一道求连续片段最大总和的题是每个f(i)都是以自己结尾，都包含自己，这道题的f(i)因为不能选相邻，就要考虑包含自己和不包含自己的两种情况
动态规划要找到重复的操作才能一遍遍历解决，这道题如果考虑的是每个f(i)都是包含自己的最大分钟数，就要额外考虑其他情况，加其他变量，没法用一个相同的操作处理所有情况
```

6.给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。

```java
到达顶部可以看作到达第n+1台阶，dp[n+1]=min(dp[n-1]+cost[n-1],dp[n-2]+cost[n-2]),dp[i]为到第i阶台阶的最小花费，从上面可以看出，到达n+1最小花费可以递推
```

## 语法和技巧

1. 对于需要多层for循环的可以写成递归调用
2. 使用StringBuilder对字符串循环插入时，每次插入后字符串的长度就会发生变化，要注意实际应该插入的下标位置
